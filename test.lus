const
-- Boiler characteristics
  N_pump = 4;
  C = 30;    -- Maximal capacity
  M1 = 10;   -- Minimal limit
  M2 = 25;   -- Maximal limit
  N1 = 10;   -- Minimal normal
  N2 = 25;   -- Maximal normal

--Capacité pompes
  P=12; --capacité de chaque pompes

-- Mode :
  Initialization = 0;
  Normal = 1;
  Degraded = 2;
  Rescue = 3;
  Emergency_stop = 4;


------------------------Boiler Controller Node-----------------
-- a changer Correspondance Failure : (0=Pump;1=PumpController;2=Water_level;3=steam;4=Transmission)

node test(
		steam_boiler_waiting : bool;
		level:int;
		steam:int;
		valve_status:int;
		pump_state:int^N_pump;
		pump_control_state:bool^N_pump;
		Failures : int)
	returns (mode:int;
		 valve:bool;
		 open_pump:bool^N_pump;
		 close_pump:bool^N_pump;);

var currentMode : int;

let

currentMode = Initialization -> if (steam_boiler_waiting and pre(currentMode)=Initialization) and (Failures=2 or steam<>0) then Emergency_stop
                                else pre(currentMode);

-- Transitions
mode = currentMode -> currentMode;

-- gestion des pompes
open_pump[0..(N_pump-1)] = false^N_pump -> if currentMode=Initialization and level<N1 then true^N_pump
			    else if currentMode=Normal and (level<N1 or level>N2) then true^N_pump
                            else false^N_pump;
close_pump[0..(N_pump-1)] = false^N_pump -> if currentMode=Initialization and level>N1 and not(pumpOFF( N_pump, pump_state)) then true^N_pump
                  else false^N_pump;

-- gestion de la valve
valve = false -> if currentMode=Initialization and level>N2 and valve_status>0 then true
		 else false;

tel

-- fonction recursive
-- result = true si toutes les pompe sont off
node pumpOFF(const n : int; pump: int^n) returns (result: bool);
let
  result = with n=1 then pump[0]=0
          else (pump[0]=0 and pumpOFF(n-1, pump[1..n-1]));
tel
